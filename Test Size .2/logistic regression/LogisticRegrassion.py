import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score
import matplotlib.pyplot as plt
import seaborn as sns
import time

# Load the data

df = pd.read_csv("dataset.csv")

# Convert categorical columns to one-hot encoding
ohe = OneHotEncoder(sparse=False)
cat_cols = ['user', 'source', 'action']
encoded_cols = ohe.fit_transform(df[cat_cols])
#encoded_df = pd.DataFrame(encoded_cols, columns=ohe.get_feature_names(cat_cols))
encoded_df = pd.DataFrame(encoded_cols, columns=ohe.get_feature_names_out(cat_cols))

df = pd.concat([df.drop(columns=cat_cols), encoded_df], axis=1)

# Split the data into train, validation, and test sets
X = df.drop(columns=['insiderthreat'])
y = df['insiderthreat']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
start_time = time.time()
# Train the model
model = LogisticRegression()
model.fit(X_train, y_train)

# Evaluate the model
accuracy = model.score(X_test, y_test)
print("Accuracy:", accuracy)



# Make predictions on the test set
y_pred = model.predict(X_test)

precision = precision_score(y_test, y_pred)
print("Precision :", precision)
recall = recall_score(y_test, y_pred)
print("Recall    :", recall)
F1_score = f1_score(y_test, y_pred)
print("F1-score  :", F1_score)



# Calculate the training time
training_time = time.time() - start_time
print('Training time:', training_time, 'seconds')
# Build confusion matrix
cm = confusion_matrix(y_test, y_pred)

print("Confusion matrix:")
print(cm)

sns.heatmap(cm,
            annot=True,
            fmt='g',
            xticklabels=['Negative', 'Positive'],
            yticklabels=['Negative', 'Positive'])
plt.ylabel('Prediction',fontsize=13)
plt.xlabel('Actual',fontsize=13)
plt.title('Confusion Matrix',fontsize=17)
plt.show()
# Plot the confusion matrix
#plot_confusion_matrix(model, X_test, y_test)
plt.show()

model.summary()